[Список тем](README.md)

# Java
+ [Типы данных.](#Типы-данных)
+ [Модификаторы доступа.](#Модификаторы-доступа)
+ [Понятие «конструктор».](#Понятие-конструктор)
+ [Функция `main()`.](#Функция-main)
+ [Логические операции и операторы.](#Логические-операции-и-операторы)
+ [Побитовые операции.](#Побитовые-операции)
+ [Ключевое слово `static`.](#Ключевое-слово-static)
+ [Блоки инициализации.](#Блоки-инициализации)
+ [Порядок вызова конструкторов и блоков инициализации с учётом иерархии классов.](#Порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов)
+ [Класс `String`.](#Класс-string)
+ [Что такое `String pool`?](#Что-такое-string-pool)
+ [Почему `char[]` предпочтительнее `String` для хранения пароля?](#Почему-char-предпочтительнее-string-для-хранения-пароля)
+ [Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?](#Какая-основная-разница-между-string-stringbuffer-stringbuilder)
+ [Ключевое слово `final`.](#Ключевое-слово-final)
+ [Ключевое слово `abstract`.](#Ключевое-слово-abstract)
+ [Что такое `interface`?](#Что-такое-interface)
+ [Чем абстрактный класс отличается от интерфейса?](#Чем-абстрактный-класс-отличается-от-интерфейса?)
+ [Вложенные классы.](#Вложенные-классы)
+ [Статические вложенные классы.](#Статические-вложенные-классы)
+ [Нестатические вложенные классы.](#Нестатические-вложенные-классы)
+ [Локальные классы.](#Локальные-классы)
+ [Анонимные классы.](#Анонимные-классы)
+ [Приведение типов. Что такое понижение и повышение типа?](#Приведение-типов-Что-такое-понижение-и-повышение-типа)
+ [Aвтоупаковка и автораспаковка](#Автоупаковка-и-автораспаковка)
+ [Что такое класс `Object`? Какие в нем есть методы?](#Что-такое-класс-object-Какие-в-нем-есть-методы)
+ [Зачем нужен `equals()`. Чем он отличается от операции `==`?](#Зачем-нужен-equals-Чем-он-отличается-от-операции-)
+ [Свойства, которым должен удовлетворять `equals()`.](#Свойства-которым-должен-удовлетворять-equals)
+ [Какая связь между `hashCode()` и `equals()`?](#Какая-связь-между-hashcode-и-equals)
+ [Понятия JRE, JVM и JDK.](#Понятия-jre-jvm-и-jdk)
+ [Динамическая диспетчеризация методов.](#Динамическая-диспетчеризация-методов)
+ [Передача параметров в методы по значению и по ссылке.](#Передача-параметров-в-методы-по-значению-и-по-ссылке)

## Типы данных.
Глобально, типы данных в Java делятся на две большие группы:

+ _Примитивные_;
+ _Ссылочные_;

Всего в Java 8 примитивных типов данных: 

+ `byte` - целочисленный тип, занимает 8 бит;
+ `short` - целочисленный тип, занимает 16 бит;
+ `int` - целочисленный тип, занимает 32 бита;
+ `long` - целочисленный тип, занимает 64 бита;
+ `float` - число с плавающей точкой, занимает 32 бита;
+ `double` - число с плавающей точкой, занимает 64 бита;
+ `boolean` - логический тип данных (true / false);
+ `char` - символьный тип.

[к оглавлению](#java-core)

## Модификаторы доступа.
__private__ (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово `private`.

__default__, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное 
обозначение не требуется.

__protected__ (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово `protected`.

__public__ (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово `public`.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия _принципу подстановки Барбары Лисков_).

[к оглавлению](#java-core)

## Понятие «конструктор».
Конструктор - это специальный метод, который вызывается при создании нового объекта. По сути конструктор нужен для автоматической инициализации переменных.

Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

```
public class Box {
  int a;
  
  public Box(int a) {
    this.a = a;  
  }
}
```

[к оглавлению](#java-core)


## Функция `main()`.

Метод `main()` — точка входа в программу. 

В приложении может быть несколько таких методов.

Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка _\`Error: Main method not found\`_.

```java 
public static void main(String[] args) {}
```

[к оглавлению](#java-core)

## Логические операции и операторы.
+ `&`: Логическое _AND_ (И);
+ `&&`: Сокращённое _AND_;
+ `|`: Логическое _OR_ (ИЛИ);
+ `||`: Сокращённое _OR_;
+ `^`: Логическое _XOR_ (исключающее _OR_ (ИЛИ));
+ `!`: Логическое унарное _NOT_ (НЕ);
+ `&=`: _AND_ с присваиванием;
+ `|=`: _OR_ с присваиванием;
+ `^=`: _XOR_ с присваиванием;
+ `==`: Равно;
+ `!=`: Не равно;
+ `?:`: Тернарный (троичный) условный оператор.

[к оглавлению](#java-core)

## Побитовые операции.
+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

[к оглавлению](#java-core)

## Ключевое слово `static`.
В Java ключевым словом static помечают члены (поля или методы), которые принадлежат классу, а не экземпляру этого класса.

Ключевое слово `static` применяется к:

+ полям класса;
+ методам класса;
+ блокам инициализации;
+ импорту;
+ вложенным классам (nested classes);

_Статическое поле_ - значение такого поля будет единым и общим для всех объектов класса, содержащих это поле.

_Статический метод_ - также принадлежат классу, поэтому их можно вызывать без создания экземпляра класса, в котором они находятся. При этом следует помнить, что из статического метода можно получить доступ только к статическим переменным или к другим статическим методам.

_Статический блок инициализации_ - используется для инициализации статических переменных.

_Статический импорт_ - позволяет обращаться к статическим членам класса непосредственно по имени члена, без дополнительного указания имени класса и пакета. Основная цель статического импорта — улучшение читабельности кода программы благодаря устранению постоянного повторения имени класса.

_Статический вложенный класс_ - это вложенный класс, который имеет доступ только к статическим членам внешнего класса.

[к оглавлению](#java-core)

## Блоки инициализации.
_Блок инициализации_ — понятие в объектно-ориентированном программировании, которое представляет собой последовательность команд, выполняемых при создании классов и объектов.

Существует всего два типа блоков:

+ _нестатический_;
+ _статический_;

Статический блок используется для инициализации статических переменных и вызывается один раз при первой загрузке класса.

Нестатический блок используется для инициализации переменных и вызывается каждый раз при создании объекта класса.

[к оглавлению](#java-core)

## Порядок вызова конструкторов и блоков инициализации с учётом иерархии классов.
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса. 

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

```
Parent static block(s) → Child static block(s) → Grandchild static block(s)
→ Parent non-static block(s) → Parent constructor →
→ Child non-static block(s) → Child constructor →
→ Grandchild non-static block(s) → Grandchild constructor
```

[к оглавлению](#java-core)

## Класс `String`.
+ Это неизменяемый (immutable) и финализированный тип данных;
+ Все объекты класса `String` JVM хранит в пуле строк;
+ Объект класса `String` можно получить, используя двойные кавычки;
+ Можно использовать оператор `+` для конкатенации строк;
+ Начиная с Java 7 строки можно использовать в конструкции `switch`.

[к оглавлению](#java-core)

## Что такое «String pool»?
+ Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
+ Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
+ Когда для создания строки используются `"`, то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
+ При использовании оператора `new` создаётся новый объект `String`.

[к оглавлению](#java-core)

## Почему `char[]` предпочтительнее `String` для хранения пароля?
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста.
В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.

[к оглавлению](#java-core)

## Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?
Класс `String` является неизменяемым (_immutable_) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс `StringBuffer` изменяемый - использовать `StringBuffer` следует тогда, когда необходимо часто модифицировать содержимое. 

Класс `StringBuilder` был добавлен в Java 5 и он во всем идентичен классу `StringBuffer` за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

[к оглавлению](#java-core)

## Ключевое слово `final`.
Ключевое слово `final` применяется к:

+ классам;
+ полям класса;
+ методам класса;

`final` class - класс, от которого нельзя унаследоваться, т.е. нельзя создать классов-наследников.

`final` method - метод, который нельзя переопределить в классах наследниках. Такие методы еще называют завершенными.

```
Конструктор не может быть объявлен как final
```

`final` field - поле, для которого запрещено изменение содержимого переменной, сделав ее, по существу, константой.

[к оглавлению](#java-core)

## Ключевое слово `abstract`.
Ключевое слово `abstract` применяется к:

+ классам;
+ методам класса;

Абстрактный класс может выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Абстрактный метод не имеет тела. Такие методы необходимо переопределять в классах наследниках.

Если класс имеет хоть один абстрактный метод - такой класс обязан быть абстрактным

[к оглавлению](#java-core)

## Что такое `interface`?
Ключевое слово `interface` используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как `public`.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию `default` и статических `static` методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными `public`, статическими `static` и неизменяемыми `final`.

[к оглавлению](#java-core)

## Чем абстрактный класс отличается от интерфейса?
+ В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
+ Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
+ Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как `public abstract` или (начиная с Java 8) `default` - методами с реализацией по-умолчанию, а поля - `public static final`.
+ Интерфейсы позволяют создавать структуры типов без иерархии.
+ Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.

[к оглавлению](#java-core)

## Вложенные классы.
Класс называется вложенным (_Nested class_), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов: 
+ _Static nested class_ (Статический вложенный класс);
+ _Member inner class_ (Простой внутренний класс);
+ _Local inner class_ (Локальный класс);
+ _Anonymous inner class_ (Анонимный класс).

Особенности использования вложенных классов:

+ Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным. 
+ Для создания объекта статического вложенного класса объект внешнего класса не требуется.
+ Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
+ Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.
+ В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание `.this` после его имени. Например: `Outer.this`.

## Статические вложенные классы.
Статический вложенный класс - это вложенный класс, объявленный с использованием ключевого слова `static`. К классам верхнего уровня модификатор `static` неприменим.

[к оглавлению](#java-core)

## Нестатические вложенные классы.
Статический вложенный класс - это обычный вложенный класс, объявленный как нестатическое поле класса.

[к оглавлению](#java-core)

## Локальные классы.
Локальный класс - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые вложенные классы, локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.

[к оглавлению](#java-core)

## Анонимные классы.
Анонимный класс - это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

[к оглавлению](#java-core)

## Приведение типов. Что такое понижение и повышение типа?
Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм _приведения типов (casting)_ - способ преобразования значения переменной одного типа в значение другого типа. 

В Java существуют несколько разновидностей приведения:

+ __Тождественное (identity)__. Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
+ __Расширение (upcasting) примитивного типа__. Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа `byte` к типу `int`. Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
+ __Сужение (downcasting) примитивного типа__. Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.
+ __Расширение объектного типа (widening reference)__. Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
+ __Сужение объектного типа (narrowing reference)__. Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение `ClassCastException`. Требует явного указания типа.
+ __Преобразование к строке (to String)__. Любой тип может быть приведен к строке, т.е. к экземпляру класса `String`.
+ __Запрещенные преобразования (forbidden)__. Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.

[к оглавлению](#java-core)

## Autoboxing («автоупаковка») в Java. Каковы правила упаковки примитивных типов в классы-обертки?
__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива, соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не должен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

[к оглавлению](#java-core)

## Что такое класс `Object`? Какие в нем есть методы?
`Object` - это базовый класс для всех остальных объектов в Java. Любой класс наследуется от `Object` и, соответственно, наследуют его методы:

`public boolean equals(Object obj)` – служит для сравнения объектов по значению;

`int hashCode()` – возвращает hash код для объекта;

`String toString()` – возвращает строковое представление объекта;

`Class getClass()` – возвращает класс объекта во время выполнения;

`protected Object clone()` – создает и возвращает копию объекта;

`void notify()` – возобновляет поток, ожидающий монитор;

`void notifyAll()` – возобновляет все потоки, ожидающие монитор;

`void wait()` – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout, int nanos)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`protected void finalize()` – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

[к оглавлению](#java-core)

## Зачем нужен `equals()`. Чем он отличается от операции `==`?
Метод `equals()` - определяет отношение эквивалентности объектов.

При сравнении объектов с помощью `==` сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком `equals()` - по внутреннему состоянию объектов.

[к оглавлению](#java-core)

## Свойста, которым должен удовлетворять `equals()`.
+ Рефлексивность - x.equals(x) возвращает true.
+ Симметричность - x.equals(y) <=> y.equals(x).
+ Транзитивность - x.equals(y) <=> y.equals(z) <=> x.equals(z).
+ Согласованность - повторный вызов x.equals(y) должен возвращать значение предыдущего вызова, если сравниваемые поля не изменялись.
+ Сравнение null - x.equals(null) возвращает false.

[к оглавлению](#java-core)

## Какая связь между `hashCode()` и `equals()`?
`equals()` - метод, проверяющий два объекта одного происхождения на логическую равность.

`hashcode()` - для получения уникального целочисленного номера объекта, своего рода его идентификатор.

Контракт `hashCode()` и `equals()` в Java:

+ Повторный вызов hashCode для одного и того же объекта должен возвращать одинаковые хеш-значения, если поля объекта, участвующие в вычислении значения, не менялись.
+ Если equals() для двух объектов возвращает true, hashCode() также должен возвращать для них одно и то же число.
+ Для неравных между собой объектов hashCode должен возвращать разные хеш-значения.

[к оглавлению](#java-core)

## Понятия JRE, JVM и JDK.
__JVM__, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

__JRE__, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

__JDK__, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

Коротко: __JDK__ - среда для разработки программ на Java, включающая в себя __JRE__ - среду для обеспечения запуска Java программ, которая в свою очередь содержит __JVM__ - интерпретатор кода Java программ.

[к оглавлению](#java-core)

## Динамическая диспетчеризация методов.
_Динамическая диспетчеризация методов_ - это механизм, с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции.

Динамическая диспетчеризация важна потому, что благодаря ей полиморфизм в Java реализуется во время выполнения.

[к оглавлению](#java-core)

## Передача аргументов в методы по значению и по ссылке.
При передачи аргументов по значению значения фактических параметров копируются. Вызываемый метод создает свою копию значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это никак не влияет.

При передачи аргументов по ссылке параметры передаются как ссылка (адрес) на исходную переменную. Вызываемый метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные в вызываемом методе, также будут отражены в исходном значении.

В Java аргументы всегда передаются по значению.

[к оглавлению](#java-core)
