[Список тем](../README.md)

[<- Назад](../java.md)

# Java 8
+ [`Default` методы интерфейса.](#Default-методы-интерфейса)
+ [Функциональные интерфейсы.](#Функциональные-интерфейсы)
+ [Лямбда выражения.](#Лямбда-выражения)
+ [Захват переменных.](#Захват-переменных)
+ [Что такое _"Method reference"_?](#Лямбда-выражения)
+ [Класс `Optional<T>`.](#Класс-optionalt)
+ [`Stream API`.](#Stream-api)
+ [`Date Time API`.](#Date-time-api)
+ [Класс `StringJoiner<T>`.](#Класс-stringjoinert)

## `Default` методы интерфейса.
Java 8 позволяет добавлять неабстрактные методы в интерфейс со своей реализацией, 
используя ключевое слово `default`:

```
interface Example {
    default void show() {
        System.out.println("default show()");
    }
}
```
Преимущества `default` методов:
+ Класс, реализующий интерфейс, может, но не обязан, реализовать `default` методы.
+ Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, 
то класс должен реализовать метод с совпадающей сигнатурой самостоятельно.
+ Метод по умолчанию не может переопределить метод класса java.lang.Object.
+ Помогают реализовывать интерфейсы без страха нарушить работу других классов.
+ Позволяют избежать создания служебных классов, так как все необходимые методы 
могут быть представлены в самих интерфейсах.
+ Дают свободу классам выбрать метод, который нужно переопределить.

[к оглавлению](#java-core)

## Функциональные интерфейсы.
Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.

Чтобы точно определить интерфейс как функциональный, добавлена аннотация `@FunctionalInterface`, 
работающая по принципу `@Override`. Она обозначит замысел и не даст определить второй 
абстрактный метод в интерфейсе.

Интерфейс может включать сколько угодно `default` методов и при этом оставаться функциональным, 
потому что `default` методы - не абстрактные.

[к оглавлению](#java-core)

## Лямбда выражения.
Лямбда представляет собой набор инструкций, которые можно выделить в отдельную переменную 
и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку `->`. 
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список 
параметров выражения, а правая представляет тело лямбда-выражения, 
где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного 
в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать 
только один единственный метод без реализации.

```
interface Calculator {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Calculator calculator = (x, y) -> x + y;
    int result = operation.calculate(10, 20); // result = 30
}
```

По факту лямбда-выражения являются сокращенной формой внутренних анонимных классов, которые 
ранее применялись в Java.

```
interface Calculator {
    int calculate(int x, int y);
}

public static void main(String[] args) {

    // Использования анонимного класса для реализации метода интерфеса
    Calculator calculator1 = new Calculator() {
      @Override
      public int calculate(int x, int y) {
        return x + y;
      }
    };
    
    // Использование лямбда-выражения
    Calculator calculator2 = (x, y) -> x + y;
    
    int a = calculator1.calculate(10, 20); // a = 30
    int b = calculator1.calculate(10, 20); // b = 30
  }
```

Параметры лямбда-выражения должны соответствовать по типу параметрам метода функционального 
интерфейса:
```
// При написании самого лямбда-выражения тип параметров разрешается не указывать:
    (x, y) -> x + y;
// Если метод не принимает никаких параметров, то пишутся пустые скобки, например:
    () -> 30 + 20;
// Если метод принимает только один параметр, то скобки можно опустить:
    n -> n * n;
```

Блочные лямбда-выражения обрамляются фигурными скобками. В блочных лямбда-выражениях 
можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, 
создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, 
то явным образом применяется оператор `return`:
```
Calculator Calculator = (int x, int y) -> {
    if (x == 0 || y == 0) {
        return 0;
    } else {
        return x + y;
    }
};
```
Также лямбда-выражения можно передавать в качестве параметра метода:
```
public static int sum(Calculator calculator, int x, int y) {
    return calculator.calculate(x, y);
}

public static void main(String[] args) {
    int result = sum((x,y) -> x + y, 10, 20); // result = 30
}
```
[к оглавлению](#java-core)

## Захват переменных.
Доступ к переменным внешней области действия из лямбда-выражения очень схож 
к доступу из анонимных объектов. Можно ссылаться на:
+ неизменяемые (`final`) локальные переменные;
+ поля класса;
+ статические переменные.

Но если в лямбда-выражении используется локальная переменная из объемлющей его области 
видимости, то возникает особый случай, называемый _захватом переменной_.

В этом случае в лямбда-выражении можно использовать только те локальные переменные, 
которые действительно являются конечными. Действительно конечной считается такая переменная, 
значение которой не изменяется после ее первого присваивания. 

Такую переменную совсем не обязательно объявлять как `final`, хотя это и не считается ошибкой.

Следует, однако, иметь в виду, что локальная переменная из объемлющей области видимости 
не может быть видоизменена в лямбда-выражении, иначе будет вызвана ошибка компиляции.

[к оглавлению](#java-core)

## Что такое _"Method reference"_?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться 
механизмом `method reference` (ссылка на метод) для непосредственной передачи этого метода.
Для этого необходимо использовать конструкцию `::`.

Существует три вида ссылки на метод:
+ на статический метод ```Класс :: метод```
+ на нестатический методы ```объект :: метод```
+ на конструктор класса ```Класс :: new```

Результат будет в точности таким же, как в случае определения лямбда-выражения, 
которое вызывает этот метод, но ссылки на методы потенциально более эффективны, 
чем использование лямбда-выражений. 

Кроме того, они предоставляют компилятору более качественную информацию о типе 
и при возможности выбора между использованием ссылки на существующий метод и 
использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.

[к оглавлению](#java-core)

## Класс `Optional<T>`.
Optional — это контейнер для объекта, который может содержать или не содержать значение null.

Такая обёртка является удобным средством предотвращения NullPointerException, т.к. 
имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся 
_if null / notNull_ проверок:

```
Optional<String> optional = Optional.of("hello");

optional.isPresent(); // true
optional.ifPresent(s -> System.out.println(s.length())); // 5
optional.get(); // "hello"
optional.orElse("ops..."); // "hello"
```

[к оглавлению](#java-core)

## `Stream API`.
`Stream API` — это новый способ работать со структурами данных в функциональном стиле.
По своей сути это поток данных.

Для начала работы стриму нужен источник, из которого он будет получать объекты. 
Чаще всего это коллекции, но иногда можно взять в качестве источника генератор, 
у которого заданы правила создания объектов.

Все данные источника проходят через методы (операторы) стрима.

Операторы можно разделить на две группы:
+ Конвейерные - обрабатывают поступающие элементы и возвращают стрим. 
Промежуточных операторов в цепочке обработки элементов может быть много.
+ Терминальные - обрабатывают элементы и завершают работу стрима, 
так что терминальный оператор в цепочке может быть только один.

Важные моменты использования `Stream API`:
+ Работа стрима не начнётся до тех пор, пока не будет вызван терминальный оператор.
+ Экземпляр, стрима нельзя использовать более одного раза.

Некоторые конвейерные операторы:
```
filter - вернет значения, которые подходят под заданное условие;
sorted - отсортирует элементы в естественном порядке. Можно использовать Comparator;
limit - лимитирует вывод по количеству;
skip - пропустит указанное количество элементов;
distinct - найдет и уберет элементы, которые повторяются; вернет элементы без повторов;
peek - выполнить действие над каждым элементом элементов, вернет стрим с исходными элементами;
map - выполнит действия над каждым элементом и вернет элементы с результатами функций;
flatMap - сработает как map, но преобразует один элемент в ноль, один или множество других;
```

Некоторые терминальные операторы:
```
findFirst - вернет значения, которые подходят под заданное условие;
findAny - отсортирует элементы в естественном порядке. Можно использовать Comparator;
collect - лимитирует вывод по количеству;
count - пропустит указанное количество элементов;
anyMatch - возвращает true, когда хотя бы один элемент соответствует условию;
noneMatch - возвращает true, когда ни один элемент не соответствует условию;
allMatch - возвращает true, когда все элементы соответствуют условию;
min - найдет самый маленький элемент, используя переданный Comporator;
max - найдет самый большой элемент, используя переданный Comporator;
forEach - применит функцию ко всем элементам, но порядок выполнения гарантировать не может;
toArray - приведет значения стрима к массиву;
```

Специальные операторы, которые работают только со стримами с числовыми примитивами:
```
sum - вернет сумму чисел, представленных в коллекции;
average - вернет среднее арифметическое;
mapToObj - преобразует числовой стрим в объектный;
```

[к оглавлению](#java-core)


## `Date Time API`.
Список новых классов в java.time:

+ LocalDate –  дата без времени и временных зон;
+ LocalTime – время без даты и временных зон;
+ LocalDateTime – дата и время без временных зон;
+ ZonedDateTime – дата и время с временной зоной;
+ DateTimeFormatter – форматирует даты в строки и наоборот, только для классов java.time;
+ Instant – колличество секунд с Unix epoch time (полночь 1 января 1970 UTC);
+ Duration – продолжительность в секундах и наносекундах;
+ Period – период времени в годах, месяцах и днях;
+ TemporalAdjuster – корректировщик дат;

Плюсы Date Time Api:
+ для работы с временем выделен отдельный пакет java.time;
+ названия классов даны более осмысленно;
+ все классы в новом API неизменяемые и как следствие потоко-безопасные;
+ точность представления времени составляет одну наносекунду;
+ теперь все действия требуют явное указание временной зоны, где это необходимо;
+ введен специальный абстрактный класс java.time.Clock для тестирования;
+ номера месяцев идут с 1. Появилось новое перечисление java.time.Month;
+ в новом API определены специальные классы для длительности и периодов.

[к оглавлению](#java-core)

## Класс `StringJoiner<T>`.
Класс `StringJoiner` используется, чтобы создать последовательность строк, 
разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:

```
StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");

for (String s : "Hello the brave world".split(" ")) {
    joiner.add(s);
}

System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```

[к оглавлению](#java-core)
