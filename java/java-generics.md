[Список тем](../README.md)

[<- Назад](../java.md)

# Java Generics
+ [Generics (Обобщения).](#Generics-обобщения)
+ [Параметризованные классы.](#Параметризованные-классы)
+ [Параметризованные методы.](#Параметризованные-классы)
+ [Ковариантность, контравариантность и инвариантность.](#Ковариантность-контравариантность-и-инвариантность)
+ [Ограничение типа.](#Ограничение-типа)
+ [Generics с иерархией классов.](#Generics-с-иерархией-классов)
+ [Что такое Wildcard?](#Что_такое_Wildcard)
+ [The Get and Put Principle или PECS.](#The_get_and_put_principle_или_pecs)
+ [Wildcard без ограничений.](#Wildcard_без_ограничений)
+ [Что такое Raw Types?](#Что-такое-raw-types)
+ [Что такое Wildcard Capture?](#Что-такое-wildcard-capture)
+ [Множественные ограничения.](#Множественные_ограничения)
+ [Что такое _«затирание типов»_?](#Что_такое_затирание_типов)

## Generics (Обобщения).
Generics - это технический термин, обозначающий набор свойств языка позволяющих определять 
и использовать обобщенные типы и методы.

Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.

Ошибки, связанные с некорректным использованием типов, теперь обнаруживаются на этапе компиляции

[к оглавлению](#java-core)

## Параметризованные классы.
Чтобы объявить параметризованный класс, необходимо после имени класса
поставить угловые скобки с указанием типа внутри:

```
public class SomeClass<T> {
    ...
}
```

Мы можем объявлять классы с указанием нескольких обобщеных типов:

```
public class AnotherClass<T, G, E> {
    ...
}
```
[к оглавлению](#java-core)

## Параметризованные методы.
Если мы хотим использовать универсальный тип `Т` как параметр метода, то нам необходимо
добавить тип в сигнатуру метода:

```
public <T> List<T> someMethod(T t) {
    ...
}
```
`<T>` в сигнатуре метода подразумевает, что метод будет иметь дело с универсальным типом T.

Методы могут работать с более чем одним универсальным типом.
В этом случае мы должны добавить все универсальные типы в сигнатуру метода:

```
public <T, G, E> List<G> anotherMethod(T t, Function<G, E>) {
    ...
}
```
[к оглавлению](#java-core)

## Ковариантность, контравариантность и инвариантность.
_Ковариантность_ — это сохранение иерархии наследования исходных типов в 
производных типах в том же порядке.

```
Например, если Cat — это подтип Animal, то List<Cat> - подтип List<Animal>.
Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

List<Animal>  = List<Cat>
```

_Контравариантность_ — это обращение иерархии исходных типов на противоположную в
производных типах.

```
Если Cat — это подтип Animal, то List<Animal> - подтип List<Cat>.
Следовательно можно выполнить такое присваивание:

List<Cat>  = List<AnimalCat>
```

_Инвариантность_ — отсутствие наследования между производными типами.

```
Если Cat — это подтип Animal, то List<Animal> не является подтипом List<Cat>, 
как и наоборот.
```

Java Generics (обобщения) - инвариативны.

[к оглавлению](#java-core)

## Ограничение типа.
Так как обобщения инвариативны, то для обхода этой проблемы в Java 
ввели ограничения типа сверху и снизу. 

Верхняя граница - позволяет использовать указанный базовый тип или его подтипы:

```
public class Test<T extends Number> {
    // в качестве типа может использоваться класс Number
    // или все его наследники (например, Integer)
}
```

Нижняя граница - позволяет использовать указанный базовый тип или его родительские классы:

```
public class Test<T super Integer> {
    // в качестве типа может использоваться класс Integer
    // или все его родительские классы (например, Number)
}
```

[к оглавлению](#java-core)

## Что такое Wildcard?
`Wildcard` - вуниверсальном коде знак вопроса (?) - представляет неизвестный тип. 

`Wildcard` можно использовать:
+ как тип параметра;
+ как тип поля;
+ как тип локальной переменной.

Подстановочный знак никогда не используется в качестве аргумента типа для вызова 
универсального метода, создания экземпляра универсального класса или супертипа.

Wildcards можно применять для ограничений типов:
```
List<? extends Number> list1 = new ArrayList<Integer>();

List<? super Integer> list2 = new ArrayList<Number>();
```
[к оглавлению](#java-core)

## The Get and Put Principle или PECS.
Особенность `Wildcard` с использованием верхней и нижней границей накладывает 
некоторые ограничения. Из одного типа переменных можно только читать, 
в другой — только вписывать.

```
Если мы объявили <? extends Some>, то это Producer. Он только предоставляет 
элемент из контейнера, а сам ничего не принимает.

Если же мы объявили <? super Some> — то это Consumer. Он только принимает, а предоставить 
ничего не может.
```

Чтобы было легче запомнить, когда какой wildcard использовать, существует принцип 
PECS — `Producer Extends Consumer Super`.

[к оглавлению](#java-core)

## Wildcard без ограничений.
Мы можем использовать `Wildcard` без ограничений, поставив <?>:

```
public static void printCollection(Collection<?> c) {
    ...
}
```

Запись вида Collection<?> равносильна Collection<? extends Object>, поэтому в 
данный контейнер является "продюсером" и не может принимать элементы.

[к оглавлению](#java-core)

## Что такое Raw Types?
Raw Types (сырые типы) - это типы без указания "уточненения" в угловых скобках. 

Эту возможность оставили в языке для совместимости со старым кодом, который был
написан до появления дженериков.

```
List list1 = new ArrayList(); // с применением Raw Types

List<String> list2 = new ArrayList<>(); // с применением Generics
```

[к оглавлению](#java-core)

## Что такое Wildcard Capture?
При использовании Wildcard без ограничений Java не позволяет производить запись 
в контейнер:

```
public void copy(List<?> list) {

  List<Object> tmp = new ArrayList<Object>(list);
  
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(i)); // compile-time error
  }
}
```

Однако, можно использовать паттерн `Wild Capture` (или захват символа подстановки):

```
public static void copy(List<?> list) { 
  rev(list); 
}

public <T> void help(List<T> list) {

  List<T> tmp = new ArrayList<T>(list);
  
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(i)); // compile-time error
  }
}
```

В этом случае Java будет знать, какой тип параметра был передан в методе, т.е.
произойдет захват символа подстановки.

[к оглавлению](#java-core)

## Множественные ограничения.
В Java можно использовать множественные ограничения типа. Например:
```
public <T extends Numbers & Comparable<T>> T max(Collection<T> coll);
```

[к оглавлению](#java-core)

## Что такое _«затирание типов»_?
Затирание типов - процесс отбрасывания дженериков во время компиляции.

[к оглавлению](#java-core)
